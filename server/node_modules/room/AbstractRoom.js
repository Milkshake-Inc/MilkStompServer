var _ = require('lodash');
var util = require('util');
var EventEmitter = require('events').EventEmitter;

var Packet = require('packets/GamePackets');

var heartBeatInterval = 5000;

function AbstractRoom(id, type, capacity) {
    EventEmitter.call(this);
    this.id = id;
    this.type = type;
    this.capacity = capacity;
    this.playerStore = {};
    
    this.heartbeat = setInterval(function() {
        this.sendHeartbeat()
    }, heartBeatInterval).bind(this);
}

Object.defineProperty(AbstractRoom.prototype, 'players', {
    get: function() { return _.toArray(this.playerStore()); }
});

AbstractRoom.prototype.sendTo = function sendTo(players, packet) {
    for (var i = 0; i < players.length; i++) {
        if (this.getPlayerById(players[i].id) !== null) players[i].send(packet);
    }
}

AbstractRoom.prototype.sendToAll = function sendToAll(packet, excludedUser) {
    var players = excludedUser ? _(this.players).remove(function(e){ return e.id == excludedUser.id; }) : this.players;
    
    sendTo(players, packet);
};

AbstractRoom.prototype.addPlayer = function addUser(player) {
    if (_.has(this.playerStore, player.id)) {
        var err = new Error("Player already in the room: " + this.type + ":" + this.id);
        console.error(err.stack);
    } else {
        player.room = this;
        sendToAll(Packet.playerCreatePacket(player));
        this.playerStore[player.id] = player;
    }
};

AbstractRoom.prototype.removePlayer = function removePlayer(player) {
    if (_.has(this.playerStore, player.id)) {
        delete this.playerStore[player.id];
        this.emit('removedPlayer', this, player);
        player.room = null;
        sendToAll(Packet.playerRemovePacket(player));
    } else {
        var err = new Error("User does not exist in this shard: " + this.type + ":" + this.id);
        console.error(err.stack);
    }
};

AbstractRoom.prototype.getPlayerById = function getPlayerById(id) {
    return this.playerStore[id];
};

AbstractRoom.prototype.sendHeartbeat = function() {
    sendToAll(this.players, Packet.heartbeat());
};

AbstractRoom.prototype.isFull = function() {
    return _.size(this.players) >= this.capacity;
};

AbstractRoom.prototype.isEmpty = function() {
    return _.size(this.players) == 0;
};

AbstractRoom.prototype.destroy = function() {
    clearInterval(this.heartbeat);
};

util.inherits(AbstractRoom, EventEmitter);
module.exports = AbstractRoom;